# AST 노드: 코드의 설계도를 이루는 요소들

[파서](./parser.md)가 달빛약속 코드를 면밀히 분석하여 만들어내는 **AST(추상 구문 트리)**는, 마치 잘 짜인 건축물의 정교한 설계도와 같습니다. 이 설계도는 다양한 형태와 기능을 가진 **AST 노드(Node)**라는 기본적인 구성 요소들로 이루어지며, 각각의 노드는 코드 내 특정 구문이나 논리적 구조를 나타냅니다. 예를 들어, '만약'이라는 조건 판단을 위한 노드, 숫자를 표현하는 노드, 또는 함수(약속)를 호출하는 동작을 지시하는 노드 등이 있습니다.

달빛약속에서 이러한 AST 노드들은 `core/node/` 디렉토리 내에 각각의 클래스로서 체계적으로 정의되어 있습니다. 이 문서는 주요 노드들이 어떤 공통된 기반 위에서 어떻게 다양한 역할을 수행하는지, 그 기본적인 역할과 계층 구조를 안내하고자 합니다.

## 모든 노드의 근간: 기본 노드 클래스 (`core/node/base.ts`)

달빛약속의 모든 AST 노드들은 몇 가지 핵심적인 특징과 기능을 공유하며, 이는 `base.ts` 파일에 정의된 세 가지 주요 부모 클래스로부터 비롯됩니다. 이 클래스들은 노드 계층 구조의 기초를 이룹니다.

*   **`Node` 클래스**:
    *   모든 AST 노드의 가장 근원적인 조상 클래스입니다. 코드에서 우리가 마주하는 거의 모든 문법적 요소는 어떤 형태로든 이 `Node`의 속성을 지니게 됩니다.
    *   **`tokens: Token[]`**: 해당 노드가 소스 코드의 어떤 토큰(들)로부터 비롯되었는지 그 출처 정보를 소중히 간직합니다. 이 정보는 프로그램 실행 중 오류가 발생했을 때, "바로 이 부분에서 문제가 발생했습니다!" 하고 정확한 위치를 알려주거나, 다양한 개발 도구가 코드의 특정 구문을 이해하고 분석하는 데 결정적인 단서가 됩니다.
    *   **`position: Position`**: 노드가 시작되는 코드 내에서의 정확한 위치(줄 번호, 열 번호)를 나타냅니다.
    *   **`static friendlyName: string`**: "숫자 값 노드", "만약문 노드"처럼, 각 노드의 종류를 사람이 이해하기 쉬운 우리말로 설명해주는 일종의 별칭입니다. 이는 주로 개발 과정에서 디버깅을 하거나 로그를 분석할 때, 노드의 종류를 명확하게 식별하는 데 도움을 줍니다.
    *   **`validate(scope: Scope): YaksokError[]`**: (실질적으로는 각 하위 노드 클래스에서 구체적인 내용이 채워집니다) 이 노드가 현재 프로그램의 문맥, 즉 스코프(Scope) 내에서 문법적으로나 의미적으로 올바르게 사용되었는지 검증하는 중요한 역할을 합니다. 예를 들어, 선언되지 않은 변수를 사용하려 하지는 않는지, 혹은 약속된 타입과 다른 타입의 값을 전달하려 하지는 않는지 등을 꼼꼼히 확인하고, 발견된 문제점(오류)들을 모아 알려줍니다.
    *   **`toJSON(): object`**: 노드가 가진 정보들을 JSON(JavaScript Object Notation)이라는 표준 형식의 객체로 변환합니다. 이는 AST의 전체 구조를 시각적으로 표현하거나, 다양한 분석 도구에서 AST 데이터를 활용하고자 할 때 매우 유용합니다.
    *   **`toPrint(): string`**: (실질적으로는 각 하위 노드 클래스에서 구체적인 내용이 채워집니다) 해당 노드를 사람이 읽을 수 있는 간결하고 명료한 문자열 형태로 표현합니다. 이는 코드의 특정 부분을 요약하여 보여주거나, 디버깅 과정에서 현재 어떤 노드가 처리되고 있는지 쉽게 파악하는 데 도움을 줄 수 있습니다.

*   **`Executable` 클래스 ( `Node` 클래스를 계승 )**:
    *   이름에서 짐작할 수 있듯이, '실행 가능한' 모든 AST 노드들의 부모 클래스입니다. 즉, 이 클래스를 상속받는 노드들은 프로그램이 실행될 때 실제로 어떤 구체적인 동작을 수행하거나 어떤 결과를 도출해내는 역할을 담당합니다.
    *   **`execute(scope: Scope): Promise<unknown>`**: (각 하위 노드 클래스에서 구체적인 실행 로직이 구현됩니다) 이 노드가 가진 실제 동작을 수행하는 핵심적인 메소드입니다. 현재 프로그램의 상태를 나타내는 스코프(Scope) 객체를 인자로 받아, 비동기적으로 작업을 처리하고 그 결과를 반환하거나 프로그램의 상태를 변경시키는 등의 역할을 수행합니다.

*   **`Evaluable<T extends ValueType = ValueType>` 클래스 ( `Executable` 클래스를 계승 )**:
    *   '평가 가능한' 노드, 즉 실행되었을 때 특정 [값(ValueType)](./values.md)을 결과로서 명확히 내놓는 노드들의 부모 클래스입니다.
    *   **`execute(scope: Scope): Promise<T>`**: `Executable` 클래스의 `execute` 메소드를 더욱 구체화하여, 이 노드가 실행되면 반드시 `T`라는 특정 타입의 값을 결과로 반환함을 명시합니다. 예를 들어, 숫자 리터럴을 나타내는 노드는 `NumberValue` 타입의 값을, 문자열 리터럴을 나타내는 노드는 `StringValue` 타입의 값을 반환하는 것입니다.

### 주요 기본 노드의 역할 예시

*   **`Identifier` ( `Evaluable` 클래스를 계승 )**:
    *   코드 내에 등장하는 변수의 이름이나 함수(약속)의 이름과 같은 식별자(Identifier)를 표현합니다.
    *   `value: string`: 해당 식별자가 가진 실제 이름(문자열)을 저장합니다.
    *   `execute(scope: Scope)`: 현재 스코프에서 이 이름으로 정의된 변수의 값을 찾아 반환하거나, 해당 이름의 함수(약속) 객체를 찾아 실행을 준비합니다.
    *   `validate(scope: Scope)`: 이 식별자가 현재 스코프 내에 올바르게 선언되어 사용 가능한 상태인지 등을 검증합니다.

*   **`Operator` ( `Node` 클래스를 계승, `OperatorNode` 인터페이스 구현 )**:
    *   덧셈(`+`), 뺄셈(`-`)과 같은 산술 연산자나 크기 비교 연산자 등 다양한 연산자를 표현합니다.
    *   `value: string | null`: 해당 연산자를 나타내는 기호(예: `'+'`)를 가집니다.
    *   `call(...operands: ValueType[]): ValueType`: (각 하위 특정 연산자 노드에서 구체적인 연산 로직이 구현됩니다) 실제 연산을 수행하는 핵심 메소드입니다. 예를 들어, `PlusOperator` 노드의 `call` 메소드는 두 개의 숫자 타입 값을 인자로 받아, 그 합을 새로운 숫자 타입 값으로 반환하는 역할을 할 것입니다.

*   **`Expression` ( `Node` 클래스를 계승 )**:
    *   일반적인 표현식(Expression)을 나타내는 노드이지만, 이 노드 자체는 직접 실행되어 어떤 구체적인 값을 만들어내기보다는, 파싱 과정에서 보다 구체적인 다른 노드들로 변환되기 전의 중간 단계를 표현하는 데 사용될 수 있습니다.
    *   `validate` 메소드는 이 노드가 직접적으로 실행될 수 없음을 알리는 `NotExecutableNodeError`를 반환하도록 설계될 수 있습니다.

## 달빛약속의 다채로운 AST 노드들 (`core/node/index.ts`를 통해 소개)

달빛약속은 그 문법적 다양성과 표현력을 지원하기 위해 여러 종류의 특화된 AST 노드들을 사용합니다. `core/node/index.ts` 파일은 이러한 모든 노드 클래스들을 한데 모아 프로젝트의 다른 부분에서 쉽게 참조하고 사용할 수 있도록 제공하는 역할을 합니다. 몇 가지 주요 노드들의 역할과 특징을 간략히 소개합니다.

*   **`Block`**: 여러 개의 문장(statements)들이 순차적으로 모여 이루는 코드 블록을 나타냅니다. 예를 들어, 함수(약속)의 몸체 부분, `만약` 문의 조건이 참일 때 실행되는 부분 등이 이 `Block` 노드로 표현됩니다. 내부적으로는 해당 블록에 속한 자식 노드들의 리스트(`children: Node[]`)를 중요한 속성으로 가집니다. 실행될 때에는 일반적으로 새로운 내부 스코프를 생성하고, 포함된 자식 노드들을 순서대로 실행하는 방식으로 동작합니다.

*   **`Calculation` (또는 `BinaryOperation`)**: `a + b`나 `x > y`와 같이 두 개의 피연산자(operand)를 필요로 하는 이항 연산을 표현합니다. 대부분 좌항(`left`), 연산자(`operator`), 그리고 우항(`right`)에 해당하는 자식 노드들을 가집니다. 실행 시에는 먼저 좌항과 우항의 값을 각각 평가(실행)한 후, 그 결과들을 가지고 연산자 노드의 `call` 메소드를 호출하여 최종 연산 결과를 얻습니다.

*   **`IfStatement`**: `만약 (조건식)이면 ... 그렇지 않으면 만약 (다른 조건식)이면 ... 그렇지 않으면 ...` 과 같은 흐름 제어를 위한 조건문을 나타냅니다. 핵심적으로 조건식(`condition`), 해당 조건이 참일 때 실행될 코드 블록(`body`), 그리고 선택적으로 여러 개의 `elseIfs` 부분들과 최종 `elseBody` 부분을 각각 자식 노드로 가집니다.

*   **`FunctionDeclareNode`**: 함수(달빛약속에서는 "약속")를 새롭게 정의하는 부분을 나타냅니다. 함수의 이름, 함수가 받을 파라미터(인자)들의 목록, 그리고 함수가 호출되었을 때 실행될 코드(몸체, `Block` 노드) 등의 중요한 정보를 담고 있습니다. 특히 달빛약속은 `(메시지)를 (대상)에게 전달하기`처럼 문장 구조와 유사한 유연한 함수 이름을 지원하므로, 이를 표현하기 위한 특별한 내부 구조를 가질 수 있습니다. 실행 시에는 이 정보를 바탕으로 실제 함수 로직을 담은 `FunctionValue` 객체를 생성하여 현재 스코프에 해당 함수의 이름으로 등록합니다.

*   **`FunctionCallNode`**: 이미 선언된 함수(약속)를 호출하는 부분을 나타냅니다. 어떤 함수를 호출하는지(함수의 이름 또는 해당 함수를 가리키는 식별자), 그리고 함수에 전달하는 인자(arguments)들은 무엇인지 등의 정보를 가집니다. 실행 시에는 스코프에서 호출 대상 함수를 찾고, 전달된 인자 값들을 가지고 해당 함수를 실행합니다.

*   **`ListLiteral`**: `[1, "안녕", 참]`과 같이 코드에 직접 작성된 리스트(다른 프로그래밍 언어의 배열 또는 리스트와 유사)를 표현합니다. 리스트를 구성하는 각 요소들을 자식 노드(`elements: Evaluable[]`)로 가집니다. 실행 시에는 각 요소 표현식들을 평가하여 얻은 값들로 실제 `ListValue` 객체를 생성합니다.

*   **`LiteralNode` (또는 보다 구체적으로 `StringLiteral`, `NumberLiteral`, `BooleanLiteral` 등)**: 소스 코드에 직접적으로 표현된 값, 즉 리터럴(예를 들어, 문자열 `"안녕하세요"`, 숫자 `123`, 불리언 값 `참`)을 나타냅니다. 실행 시에는 해당 리터럴이 나타내는 실제 값에 대응하는 원시 값 객체(예: `StringValue`, `NumberValue`, `BooleanValue`)를 반환합니다.

*   **`Loop` (또는 `WhileLoop`, `ForLoop` 등)**: `동안 (조건식) 반복하기 ... 끝`과 같은 반복적인 작업을 수행하는 반복문을 표현합니다. 반복을 계속할지 여부를 결정하는 조건식, 그리고 반복해서 실행될 코드 블록(몸체, `Block` 노드) 등을 주요 정보로 가집니다.

*   **`ListLoop`**: `(특정 리스트)의 (각 항목 변수)에 대해 반복하기 ... 끝`처럼, 특정 리스트의 각 요소에 대해 순차적으로 작업을 수행하는 특별한 형태의 반복문을 나타낼 수 있습니다.

*   **`VariableDeclareNode`**: `나의변수: 10`과 같이 새로운 변수를 선언하고 초기화하는 부분을 나타냅니다. 변수의 이름, (선택적으로) 변수의 타입 정보, 그리고 변수에 할당될 초기값을 나타내는 표현식 등을 정보로 가집니다.

*   **`AssignNode`**: 이미 선언된 변수에 새로운 값을 할당하는 부분(예: `나의변수 = 20`)을 나타냅니다.

*   **`ReturnNode`**: 함수(약속) 내에서 `돌려주기 <값>`이라는 구문을 통해 특정 값을 함수 호출 결과로 반환하는 부분을 표현합니다.

이 외에도 `MentionNode`(다른 파일에 정의된 요소를 현재 파일에서 사용하기 위한 구문), `FFINode`(외부 함수 인터페이스 관련 구문) 등, 달빛약속의 다양한 기능을 지원하기 위한 여러 특수 목적의 노드들이 존재할 수 있습니다.

## AST 노드의 본질적인 가치와 역할

AST 노드는 단순히 코드의 구조를 반영하는 것을 넘어, 달빛약속 언어가 실제로 작동하고 발전하는 데 있어 다음과 같이 매우 중요한 역할들을 수행합니다.

*   **코드의 명확한 구조화**: 소스 코드에서 주석이나 불필요한 공백(단, 들여쓰기와 같이 의미를 가지는 공백은 제외) 등은 제거하고, 오직 코드의 논리적이고 문법적인 핵심 구조만을 명확하게 표현하여 컴퓨터가 코드를 이해하기 용이하게 합니다.
*   **의미 분석의 토대**: 컴파일러나 인터프리터는 이 AST를 체계적으로 순회하면서 코드의 의미를 깊이 있게 분석합니다. 예를 들어, 선언되지 않은 변수를 사용했는지, 약속된 타입과 다른 방식으로 값을 사용하려고 하지는 않는지 등을 검사하는 의미 분석(Semantic Analysis) 과정이 AST를 기반으로 이루어집니다. 각 노드에 정의된 `validate` 메소드가 바로 이 과정에 적극적으로 기여합니다.
*   **코드 실행의 기본 단위**: 인터프리터는 AST의 각 노드에 정의된 `execute` 메소드를 순차적으로 호출함으로써 코드를 실제로 실행하고 프로그램의 동작을 구현합니다. ([실행기](./executer.md) 문서에서 이 과정을 더 자세히 살펴보실 수 있습니다.)
*   **코드 변환 및 최적화의 출발점**: 만약 달빛약속이 장차 더 낮은 수준의 코드(예: 바이트코드)로 컴파일되거나, 실행 효율을 높이기 위한 다양한 최적화 과정을 거치게 된다면, AST는 이러한 모든 변환 및 최적화 작업의 가장 기본적인 입력 자료이자 핵심적인 작업 대상이 됩니다.
*   **다양한 개발 지원 도구의 기반**: 코드의 구조를 정밀하게 이해하고 분석하는 정적 분석 도구, 코드 스타일의 일관성을 검사하는 린터(Linter), 코드를 보기 좋게 자동으로 정렬하는 포매터(Formatter), 특정 구문에 따라 다채로운 색상을 입혀 가독성을 높이는 구문 강조(Syntax Highlighting) 기능 등, 개발자들의 생산성을 높이는 다양한 개발 지원 도구들이 바로 이 AST 정보를 적극적으로 활용하여 구현될 수 있습니다.

결론적으로, 달빛약속에 새로운 문법 기능을 추가하거나 기존 문법의 동작 방식을 변경한다는 것은, 본질적으로 해당 기능을 표현할 새로운 AST 노드 타입을 정의하거나 기존 노드를 수정하고, 파서가 이 노드들을 올바르게 생성하도록 관련 규칙을 조정하며, 마지막으로 실행기가 이 노드들을 정확하게 해석하고 처리하도록 해당 로직을 구현하는, 서로 긴밀하게 연결된 일련의 작업 과정을 의미합니다.

## 다음 탐험지를 향하여

이렇게 잘 설계되고 구축된 AST는 이제 [실행기(Executer)](./executer.md)라는 유능한 지휘자에게 전달되어, 코드에 생명을 불어넣는 실제 실행 단계로 나아가게 됩니다. 실행기는 이 AST 설계도를 따라 코드를 한 단계씩 차근차근 실행하며, 이 과정에서 다양한 종류의 [값(Value System)](./values.md)들이 생성되고 사용되며 변화하게 됩니다. 다음 문서들에서 이처럼 흥미진진하게 펼쳐지는 달빛약속의 내부 동작들을 계속해서 탐험해보시기 바랍니다.
