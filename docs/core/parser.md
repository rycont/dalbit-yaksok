# 파서: 코드의 구조를 세우는 설계자

[토크나이저](./tokenizer.md)가 소스 코드를 의미 있는 단위인 토큰으로 정제하고 나면, 그 다음 주자는 **파서(Parser)**입니다. 파서는 이 토큰들의 배열을 입력으로 받아, 언어의 문법 규칙에 따라 코드의 전체적인 구조를 파악하고 이를 **AST(Abstract Syntax Tree, 추상 구문 트리)**라는 계층적인 자료 구조로 구축하는 역할을 담당합니다. AST는 코드의 논리적 구조를 명확하게 표현하며, 이후 [실행기](./executer.md)가 코드를 해석하고 실행하는 데 필요한 핵심적인 정보를 제공합니다.

파서와 관련된 주요 로직은 `core/prepare/parse/` 디렉토리에서 찾아보실 수 있습니다.

## 파서의 핵심 기능

*   **토큰 스트림 분석**: 토크나이저로부터 전달받은 토큰 스트림을 순차적으로 검토합니다.
*   **문법 규칙 적용**: 언어에 정의된 문법 규칙(Grammar)에 따라 토큰들의 특정 패턴을 인식합니다. 예를 들어, `만약` 키워드 토큰, 조건식 토큰, 실행 블록 토큰들의 특정 조합을 조건문으로 인지하는 방식입니다.
*   **AST 생성**: 인식된 문법적 구조에 해당하는 [AST 노드](./ast_nodes.md)를 생성하고, 이들을 상호 연결하여 전체 코드의 구조를 나타내는 트리를 형성합니다.
*   **구문 오류 진단**: 토큰 스트림이 정해진 문법 규칙을 따르지 않을 경우, 구문 오류(Syntax Error)를 감지하고 이를 보고합니다.

## 파서의 작동 원리 및 주요 구성 요소

달빛약속의 파서는 여러 정교한 메커니즘을 통해 AST를 구축합니다. 주요 파일과 로직은 다음과 같습니다.

*   **`core/prepare/parse/index.ts`**:
    *   파싱 프로세스의 시작점인 `parse(codeFile: CodeFile): ParseResult` 함수를 포함합니다. 이 함수는 `CodeFile` 객체(토큰 스트림 및 소스 코드 정보 포함)를 인자로 받아 파싱을 수행하고, 결과적으로 AST의 루트 노드와 현재 파일에서 정의되어 외부로 노출될 수 있는 동적 규칙들을 담은 `ParseResult` 객체를 반환합니다.
    *   파싱은 다음과 같은 주요 단계를 거칩니다:
        1.  **동적 규칙 생성 (`createDynamicRule`)**: 달빛약속은 특히 함수(약속) 호출과 같이 문맥에 따라 유연하게 해석될 수 있는 구문을 지원합니다. `createDynamicRule`은 현재 파일의 내용(예: 함수 선언)을 분석하여, 해당 파일 내에서의 고유한 문법적 요소를 인식하기 위한 파싱 규칙을 동적으로 생성합니다.
        2.  **초기 노드 변환 (`convertTokensToNodes`)**: 토큰들을 파서가 더 용이하게 다룰 수 있는 일반적인 `Node` 객체 형태로 일차 변환하는 단계일 수 있습니다. (구체적인 역할과 필요성은 프로젝트의 상세 설계에 따라 달라질 수 있습니다.)
        3.  **들여쓰기 분석 (`parseIndent`)**: 달빛약속은 파이썬과 같이 들여쓰기를 통해 코드 블록의 범위를 지정합니다. `parseIndent` 함수는 토큰(또는 초기 노드) 스트림에서 들여쓰기의 변화를 감지하여, 연관된 코드 그룹을 `Block` 노드로 구성합니다.
        4.  **재귀적 파싱 (`callParseRecursively`)**: 이 함수는 파싱의 핵심 로직을 수행하며, 내부적으로 `srParse.ts`에 정의된 `SRParse` 함수를 활용하여 AST를 점진적으로 구축합니다.
*   **`core/prepare/parse/srParse.ts`**:
    *   **Shift-Reduce 파싱 알고리즘**: `SRParse(nodes: Node[], rules: Rule[])` 함수는 Shift-Reduce 파싱 알고리즘을 구현합니다. 이 알고리즘은 일반적으로 스택(코드에서는 `buffer` 변수)과 입력 스트림(코드에서는 `leftNodes` 변수)을 사용합니다.
        *   **Shift 연산**: 입력 스트림에서 노드를 하나씩 가져와 스택의 상단에 추가합니다.
        *   **Reduce 연산**: 스택의 상단에 쌓인 노드들의 특정 패턴이 정의된 문법 규칙(`rules`)의 `pattern`과 일치하는지 검사합니다. 일치하는 규칙이 발견되면, 해당 노드 시퀀스를 스택에서 제거하고, 규칙의 `factory` 함수를 통해 새로운 (더 상위 레벨의) AST 노드를 생성하여 스택에 추가합니다.
        *   이 Shift와 Reduce 연산을 반복하며, 입력 스트림이 모두 처리되고 스택에 단일 루트 노드(또는 더 이상 Reduce할 수 없는 상태)만 남을 때까지 진행됩니다.
    *   `reduce(nodes: Node[], rule: Rule)`: Reduce 연산 시 특정 규칙에 따라 새로운 AST 노드를 생성하는 보조 함수입니다.
    *   `callParseRecursively(nodes: Node[], externalPatterns: Rule[][])`: 실제 파싱 과정은 다양한 우선순위와 복잡도를 가진 규칙들을 여러 단계에 걸쳐 적용하며 진행됩니다. 이 함수는 `BASIC_RULES`, `ADVANCED_RULES`, 그리고 `externalPatterns`(동적으로 생성된 규칙)을 순차적으로, 그리고 `Block` 노드 내부에 대해서는 재귀적으로 `SRParse`를 호출하여 전체 AST를 완성합니다.
*   **`core/prepare/parse/rule.ts`**:
    *   파싱 규칙(`Rule`)의 구조를 정의합니다. 각 규칙은 다음을 포함합니다:
        *   `pattern: (TOKEN_TYPE | NodeConstructor)[]`: 해당 규칙이 인식할 토큰 타입 또는 노드 생성자(클래스)의 특정 시퀀스입니다.
        *   `factory: (nodes: Node[], tokens: Token[]) => Node`: `pattern`에 일치하는 노드/토큰 시퀀스로부터 새로운 AST 노드를 생성하는 함수입니다.
        *   `flags?: RULE_FLAGS[]`: 규칙의 특성을 나타내는 추가 정보입니다. 예를 들어, `RULE_FLAGS.IS_STATEMENT`는 해당 규칙이 독립적인 문(statement)을 형성함을 명시하여, 파서가 문맥을 고려하여 규칙을 적용하는 데 도움을 줄 수 있습니다.
    *   `BASIC_RULES` 및 `ADVANCED_RULES`: 미리 정의된 파싱 규칙들의 집합입니다. 일반적으로 `BASIC_RULES`는 기본적인 표현식이나 간단한 구문 구조를, `ADVANCED_RULES`는 더 복잡하거나 연산자 우선순위와 같이 특별한 처리가 필요한 구문 구조를 정의하기 위해 계층적으로 구성됩니다.
*   **`core/prepare/parse/dynamicRule/`**:
    *   동적 파싱 규칙의 생성과 관리를 담당하는 모듈들이 위치합니다.
    *   `functions/`: 주로 함수(약속)의 선언과 호출에 관련된 동적 규칙을 생성합니다. 달빛약속의 특징 중 하나인 유연한 함수 시그니처(예: `(무엇)을 (어떻게) 하다`)를 올바르게 파싱하기 위해, 함수 선언 시 해당 함수의 고유한 호출 패턴을 인식할 수 있는 규칙을 동적으로 추가합니다.
    *   `mention/`: `언급하기` 구문을 통해 다른 파일의 요소를 현재 스코프에서 사용하고자 할 때, 해당 외부 요소에 대한 파싱 정보를 동적으로 통합하는 역할을 할 수 있습니다.
*   **`core/prepare/parse/parse-indent.ts`**:
    *   `parseIndent(nodes: Node[])` 함수는 들여쓰기 정보를 분석하여 코드 블록을 정확하게 그룹화합니다. 각 줄의 들여쓰기 수준 변화를 추적하여, 새로운 블록의 시작과 끝을 결정하고, 이를 `Block` AST 노드로 표현합니다.
*   **`core/prepare/parse/satisfiesPattern.ts`**:
    *   Shift-Reduce 파서가 Reduce 연산을 시도할 때, 현재 스택의 상단 부분이 특정 규칙의 `pattern`과 일치하는지 여부를 효율적으로 검사하는 유틸리티 함수입니다.

## 파싱 과정의 흐름

1.  **입력**: [토크나이저](./tokenizer.md)로부터 토큰 스트림을 전달받습니다.
2.  **동적 규칙 생성**: 현재 파싱할 코드 파일의 내용을 우선적으로 분석하여, 해당 파일 내에서만 유효하거나 특별히 처리해야 할 문법 요소(주로 함수 선언)에 대한 파싱 규칙을 동적으로 준비합니다.
3.  **들여쓰기 기반 블록화**: 토큰(또는 초기 노드) 스트림을 검토하며 들여쓰기 정보를 기준으로 코드 블록을 `Block` AST 노드로 구조화합니다.
4.  **Shift-Reduce 파싱 적용**:
    *   들여쓰기가 처리된 노드 스트림과 모든 파싱 규칙(기본 규칙, 고급 규칙, 동적으로 생성된 규칙)을 활용하여 `SRParse` 함수를 반복적으로 호출합니다.
    *   `SRParse` 함수는 입력 노드를 스택에 점진적으로 `shift`하고, 스택 상단이 특정 문법 규칙의 패턴과 일치하면 해당 부분을 새로운 (더 추상화된) AST 노드로 `reduce`합니다.
    *   `Block` 노드 내부의 자식 노드들에 대해서도 이 파싱 과정을 재귀적으로 적용합니다.
5.  **AST 반환**: 모든 입력이 성공적으로 처리되면, 최종적으로 구축된 AST의 루트 노드(일반적으로 전체 파일을 표현하는 최상위 `Block` 노드)를 반환합니다.

## 새로운 문법 규칙 추가 시 고려사항

달빛약속에 새로운 문법을 도입하고 이를 위한 파싱 규칙을 추가하고자 할 때는, 다음과 같은 사항들을 신중하게 고려해야 합니다.

*   **규칙의 배치**: 새로운 규칙을 `BASIC_RULES`와 `ADVANCED_RULES` 중 어디에, 그리고 규칙 배열 내의 어떤 우선순위 레벨에 배치할지는 해당 문법의 복잡성, 다른 기존 문법과의 관계 및 연산자 우선순위 등을 고려하여 결정해야 합니다.
*   **패턴의 명확성**: 규칙의 `pattern`은 새로운 문법을 구성하는 토큰 타입 및/또는 하위 AST 노드 타입의 정확하고 모호하지 않은 시퀀스를 명시해야 합니다.
*   **팩토리 함수의 정확성**: `factory` 함수는 패턴에 일치된 요소들로부터 정확한 타입의 새로운 AST 노드를 생성해야 하며, 필요한 모든 정보를 자식 노드들로부터 추출하여 새 노드의 속성으로 올바르게 설정해야 합니다.
*   **문법적 모호성 방지**: 새로운 규칙이 기존 규칙들과 충돌하여 문법적 모호성(ambiguity)을 야기하지 않도록 설계해야 합니다. 모호한 문법은 파서가 어떤 규칙을 적용해야 할지 결정할 수 없는 상황(shift/reduce 충돌 또는 reduce/reduce 충돌)을 초래할 수 있습니다.
*   **동적 규칙과의 연관성**: 만약 새로운 문법이 함수의 정의나 호출처럼 매우 유연하고 문맥 의존적인 형태를 가진다면, 정적인 규칙만으로는 부족할 수 있으며 동적 규칙 생성 메커니즘의 활용을 고려해야 할 수 있습니다.

## 다음 단계로의 연결

파서를 통해 성공적으로 AST가 생성되면, 이 정교한 코드 구조물은 [실행기(Executer)](./executer.md)에게 전달되어 실제 코드의 실행 단계로 이어집니다. AST를 구성하는 각 노드들의 구체적인 종류와 역할에 대해서는 [AST 노드 상세 설명](./ast_nodes.md) 문서에서 더 깊이 있는 정보를 얻으실 수 있습니다.
