# 값 시스템: 달빛약속 세계의 다채로운 존재들

달빛약속 프로그래밍 언어로 작성된 코드가 [실행기](./executer.md)의 지휘 아래 움직일 때, 그 과정에서 수많은 데이터, 즉 **값(Value)**들이 생겨나고, 사용되며, 변화합니다. 변수에 저장되는 숫자, 화면에 보여줄 문자열, 여러 항목을 담고 있는 목록, 심지어 우리가 직접 만든 약속(함수)까지, 이 모든 것이 달빛약속 세계에서는 고유한 '값'으로 존재합니다.

값 시스템은 바로 이러한 다양한 값들이 달빛약속 내부에서 어떻게 표현되고 다루어지는지에 대한 규칙과 체계를 정의합니다. `core/value/` 디렉토리에는 이 값들을 나타내는 다양한 클래스들이 살고 있습니다.

## 값 표현의 기본 원칙

*   **모든 것은 객체로부터**: 달빛약속 내부에서는 숫자 3, 문자열 "안녕"과 같은 단순해 보이는 값들조차도 실제로는 특별한 속성과 기능을 가진 객체로 표현됩니다. 이렇게 모든 값을 객체로 다루면, 각 값의 종류(타입)에 대한 정보를 담거나, 해당 값과 관련된 유용한 기능(메소드)을 연결하기가 매우 용이해집니다.
*   **질서 있는 계층 구조**: 모든 값 객체들은 `ValueType`이라는 공통의 조상 클래스를 상속받습니다. 이는 모든 값이 기본적인 공통점(예: 자신을 문자열로 표현하는 방법)을 가지도록 하여, 시스템 전체적으로 값을 일관되게 다룰 수 있도록 돕습니다.
*   **변하지 않는 가치, 변할 수 있는 모습 (불변성 vs 가변성)**: 숫자나 문자열, 참/거짓과 같은 기본적인 값들은 한번 만들어지면 그 내용이 변하지 않는 **불변(immutable)**의 성질을 갖는 경우가 많습니다. 반면, 여러 항목을 담는 목록이나 사용자가 직접 만드는 복잡한 데이터 구조는 그 내용이 변경될 수 있는 **가변(mutable)**의 성질을 가질 수 있습니다. (이러한 성질은 각 값 타입의 구체적인 설계에 따라 결정됩니다.)

## 값들의 보금자리: 핵심 파일과 기본 클래스

*   **`core/value/base.ts`**: 모든 값들의 고향과도 같은 파일입니다. 이곳에는 값 시스템의 가장 기본적인 토대가 되는 클래스들이 정의되어 있습니다.
    *   **`ValueType` 클래스**:
        *   달빛약속 세계에 존재하는 모든 값 객체들의 시조새와 같은, 가장 최상위 부모 클래스입니다.
        *   `static friendlyName: string`: "값", "숫자", "문자열"처럼 각 값의 종류를 사람이 이해하기 쉬운 우리말로 나타내는 이름표입니다. 주로 개발 과정에서 디버깅을 하거나 로그를 살펴볼 때, 값의 종류를 명확하게 파악하는 데 도움을 줍니다.
        *   `toPrint(): string`: 해당 값을 사람이 읽을 수 있는 보기 좋은 문자열 형태로 변환하는 방법을 정의합니다. 이 기능은 주로 `보여주기` 약속처럼 화면에 값을 출력하거나, REPL(대화형 실행 환경)에서 값의 결과를 보여주거나, 개발 중 값을 확인하는 등의 다양한 상황에서 유용하게 사용됩니다.
    *   **`PrimitiveValue<T = unknown>` 클래스 ( `ValueType`을 계승 )**:
        *   숫자, 문자열, 참/거짓(불리언)과 같이 더 이상 쪼갤 수 없는 기본적인 데이터, 즉 **원시(Primitive) 값**들을 감싸는 역할을 하는 제네릭 클래스입니다. 여기서 `T`는 실제 저장될 원시 값의 타입(예: `number`, `string`, `boolean`)을 나타냅니다.
        *   `value: T`: 실제 원시 값을 이 속성에 보관합니다.
    *   **`ObjectValue` 클래스 ( `ValueType`을 계승 )**:
        *   달빛약속에서 좀 더 복잡한 구조를 가지거나 여러 데이터를 하나로 묶어 표현하는 객체 타입 값들의 기본적인 부모 클래스가 될 수 있습니다. 예를 들어, 여러 항목을 담는 목록(List)이나, 사용자가 직접 정의하는 복합 데이터 구조, 또는 모듈과 같은 요소들이 이 `ObjectValue`의 특징을 일부 공유하거나 이를 기반으로 확장될 수 있습니다.
        *   `base.ts`에 정의된 `ObjectValue`는 현재 매우 기본적인 형태로, 주로 자신을 JSON 형식의 문자열로 표현하는 `toPrint` 기능을 제공합니다. 특정 종류의 객체 타입 값(예: 리스트)은 이를 상속받아 훨씬 더 풍부하고 특화된 기능을 추가적으로 구현하게 됩니다.

## 달빛약속의 주요 값 타입들

`core/value/` 내의 여러 파일들에서는 위에서 소개한 기본 클래스들을 바탕으로, 달빛약속에서 실제로 사용되는 다양한 종류의 구체적인 값 타입들이 정의되어 있습니다.

*   **`core/value/primitive.ts` (원시 값 친구들)**:
    *   **`NumberValue extends PrimitiveValue<number>`**: 달빛약속 세계의 모든 숫자(예: `123`, `3.14`, `-5`)를 담당합니다. 내부적으로는 JavaScript의 `number` 타입으로 실제 숫자 값을 저장합니다.
    *   **`StringValue extends PrimitiveValue<string>`**: 모든 문자열(예: `"안녕하세요"`, `'달빛약속'`)을 표현합니다. 내부적으로는 JavaScript의 `string` 타입으로 실제 문자열 데이터를 저장합니다.
    *   **`BooleanValue extends PrimitiveValue<boolean>`**: 참(true) 또는 거짓(false)을 나타내는 논리 값을 담당합니다. (예: `참`, `거짓`) 내부적으로는 JavaScript의 `boolean` 타입으로 값을 저장합니다.
    *   **`NullValue extends PrimitiveValue<null>`**: (만약 달빛약속에 명시적인 '값이 없음'을 나타내는 개념이 있다면) `null` 또는 "값이 존재하지 않음"을 나타내는 특별한 값을 정의할 수 있습니다. 달빛약속의 `없음` 키워드가 이러한 값을 표현하는 데 사용될 수 있습니다.

*   **`core/value/list.ts` (여러 값을 담는 주머니, 리스트)**:
    *   **`ListValue extends ObjectValue`**: (또는 `ValueType`을 직접 계승할 수도 있습니다) 여러 개의 값을 순서대로 담을 수 있는 리스트(다른 프로그래밍 언어의 배열 또는 리스트와 유사)를 표현합니다.
        *   `elements: ValueType[]`: 리스트에 담겨 있는 각 항목들을 `ValueType` 객체의 배열 형태로 저장합니다. 이는 리스트가 달빛약속의 어떤 종류의 값이든(숫자, 문자열, 다른 리스트, 함수 등) 요소로 포함할 수 있음을 의미합니다.
        *   리스트는 일반적으로 특정 위치(인덱스)의 요소를 가져오거나 변경하고(`get(index)`, `set(index, value)`), 새 요소를 추가하거나 삭제하며(`push(value)`, `pop()`), 현재 담고 있는 요소의 개수(길이)를 알려주는(`length()`) 등의 편리한 기능들을 제공합니다.

*   **`core/value/function.ts` (일을 시킬 수 있는 능력, 함수/약속)**:
    *   **`FunctionValue extends ValueType`**: (또는 `ObjectValue`를 계승할 수도 있습니다) 달빛약속의 함수(또는 "약속") 그 자체를 나타내는 특별한 값입니다. 함수는 달빛약속에서 일급 시민(first-class citizen)으로 취급되므로, 변수에 저장될 수도 있고, 다른 함수의 인자로 전달될 수도 있으며, 함수의 결과로 반환될 수도 있습니다.
        *   **`YaksokFunctionValue`**: 우리가 달빛약속 코드로 직접 `약속 이름(인자): ... 끝`과 같이 정의한 함수(약속)를 나타냅니다.
            *   `name: string`: 함수의 이름입니다.
            *   `parameters: ParameterDef[]`: 함수가 받을 파라미터(인자)들에 대한 정보(예: 이름, 기대하는 타입 등)를 담고 있습니다. 달빛약속의 특징인 유연한 함수 시그니처(예: `(무엇)을 (언제) 실행하기`)를 반영하는 특별한 구조를 가질 수 있습니다.
            *   `body: Block`: 함수가 호출되었을 때 실제로 실행될 코드를 담고 있는 [AST 노드](./ast_nodes.md)(`Block` 타입)입니다.
            *   `closureScope: Scope`: 이 함수가 정의될 당시의 주변 환경(스코프)을 기억하고 있습니다. 이를 클로저(closure)라고 부르며, 함수가 나중에 다른 곳에서 호출되더라도 자신이 정의되었던 시점의 변수들에 접근할 수 있게 해주는 매우 중요한 개념입니다. 함수가 호출될 때, 이 `closureScope`를 부모로 하는 새로운 실행 스코프가 만들어집니다.
            *   `run(args: ValueType[], callScope: Scope): Promise<ValueType>`: 이 함수(약속)를 실제로 실행하는 핵심 메소드입니다. 호출 시 전달된 인자 값들의 배열(`args`)과 함수가 호출된 지점의 스코프(`callScope`)를 받아, 함수 정의 시점의 `closureScope`를 기반으로 새로운 실행 스코프를 설정하고, 함수 몸체(`body`)를 실행한 후 그 결과를 반환합니다.
        *   **`BuiltinFunctionValue` (또는 `FFIFunctionValue`)**: 달빛약속 런타임 자체에 미리 만들어져 제공되는 내장 함수(예: `보여주기`, `길이 구하기`)나, FFI(Foreign Function Interface)를 통해 JavaScript 등 다른 언어로 구현된 외부 함수를 나타냅니다.
            *   `name: string`: 해당 내장 함수의 이름입니다.
            *   `execute: (args: ValueType[], scope: Scope, ...otherContext) => ValueType | Promise<ValueType>`: 실제 내장 함수의 로직을 담고 있는 JavaScript 함수입니다. 달빛약속의 값(`ValueType`)들을 인자로 받아 필요한 처리를 수행하고, 그 결과를 다시 달빛약속의 값(`ValueType`)으로 변환하여 반환합니다.

*   **`core/value/ffi.ts` (다른 세계와의 연결 통로, FFI 값)**:
    *   FFI(외부 함수 인터페이스)를 통해 JavaScript와 같은 다른 프로그래밍 언어 환경과 데이터를 주고받을 때 필요한 특별한 종류의 값들을 정의할 수 있습니다. 예를 들어, JavaScript의 객체를 달빛약속의 값으로 안전하게 감싸거나, 그 반대로 달빛약속의 값을 JavaScript 환경으로 넘겨주기 위한 매개체(프록시 객체) 등이 여기에 해당될 수 있습니다.

## 값은 어떻게 태어나고 사용될까요?

*   **코드 속 리터럴로부터**: [파서](./parser.md)가 소스 코드에서 `123`이나 `"안녕"`과 같은 리터럴(값 자체를 나타내는 표현)을 만나면, 이 리터럴에 해당하는 값 객체(예: `NumberValue(123)`, `StringValue("안녕")`)를 생성하는 [AST 노드](./ast_nodes.md)(예: `LiteralNode`)를 만듭니다. 그리고 이 AST 노드가 [실행될](./executer.md) 때, 해당 값 객체가 프로그램 내에서 실제로 사용될 수 있는 형태로 나타납니다.
*   **계산의 결과로**: `+`나 `-`와 같은 연산이 수행되면, 그 결과로 새로운 값 객체가 탄생합니다. 예를 들어, `NumberValue(1)`과 `NumberValue(2)`를 더하는 연산은 새로운 `NumberValue(3)` 객체를 만들어냅니다.
*   **함수(약속) 호출의 선물로**: 함수(약속)가 실행되고 어떤 값을 `돌려주기`로 결정하면, 그 반환되는 값 또한 달빛약속의 값 시스템에 정의된 값 객체 중 하나입니다.
*   **변수라는 이름표와 함께**: 변수에 어떤 값이 할당될 때, 해당 값 객체는 스코프 내에서 변수의 이름과 서로 연결되어 저장됩니다. 이후 변수의 이름을 부르면 이 연결된 값 객체를 사용할 수 있게 됩니다.
*   **값 스스로의 능력 (메소드 호출)**: 어떤 종류의 값 객체들은 자신과 관련된 특별한 작업들을 수행할 수 있는 능력, 즉 메소드를 가지고 있을 수 있습니다. 예를 들어, `ListValue` 객체는 자신에게 새 항목을 추가하는 `push` 메소드를 가질 수 있고, `StringValue` 객체는 자신의 글자 수를 알려주는 `길이` 속성이나 `length()` 메소드를 가질 수 있습니다.

## 값의 종류를 확인하고 변환하기

*   **"너는 누구냐?" (타입 확인)**: 달빛약속은 코드가 실행되는 동안 값의 타입을 유연하게 결정하는 동적 타입 언어의 특징을 가질 수도 있고, 또는 코드 작성 단계에서부터 타입을 엄격하게 검사하는 정적 타입 시스템의 일부를 도입할 수도 있습니다. 프로그램 실행 중에는 보통 `instanceof` 연산자(예: `value instanceof NumberValue`)를 사용하거나, 각 값 객체 내부에 저장된 타입 정보를 통해 현재 다루고 있는 값의 종류가 무엇인지 확인할 수 있습니다.
*   **"모습을 바꿔라, 얍!" (타입 변환)**: 때로는 특정 연산을 수행하기 위해 값의 타입이 자동으로 변환될 필요가 있을 수 있습니다. 예를 들어, 문자열과 숫자를 더하려고 할 때, 숫자가 문자열로 변환되어 두 문자열이 합쳐지는 것처럼 말입니다. 이러한 타입 변환(Type Coercion) 규칙은 언어의 사용성과 직관성에 큰 영향을 미치므로 신중하게 설계됩니다.

이처럼 달빛약속의 값 시스템은 언어의 동적인 특성과 풍부한 표현력을 뒷받침하는 매우 중요한 기반입니다. 개발자로서 새로운 기능을 추가하거나 기존 기능을 수정할 때, 해당 기능이 이 값 시스템과 어떻게 조화롭게 상호작용하며 데이터를 처리하는지 이해하는 것은 매우 중요합니다.
