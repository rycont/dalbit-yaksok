# 실행기: AST에 생명을 불어넣는 지휘자

[파서](./parser.md)가 정교하게 구축한 [AST(추상 구문 트리)](./ast_nodes.md)는 아직 그 자체로는 움직이지 않는 설계도와 같습니다. 이 설계도에 생명을 불어넣어 실제 프로그램으로 작동하게 만드는 역할은 바로 **실행기(Executer)**의 몫입니다. 실행기는 AST를 체계적으로 순회하며 각 [AST 노드](./ast_nodes.md)에 정의된 작업을 수행함으로써, 우리가 작성한 달빛약속 코드가 의도한 대로 동작하도록 만듭니다.

실행기와 관련된 핵심 로직은 `core/executer/` 디렉토리에서 만나보실 수 있습니다.

## 실행기의 핵심 임무

*   **AST 순회 및 실행**: AST의 루트 노드에서 시작하여, 트리의 각 노드를 방문하며 해당 노드의 `execute(scope)` 메소드를 호출합니다. 이 메소드에는 각 노드 타입에 맞는 실제 실행 코드가 담겨 있습니다.
*   **스코프(Scope) 관리**: 변수와 함수(약속)의 이름과 그 실체(값 또는 함수 객체)를 연결하고, 이들의 유효 범위(어디까지 사용 가능한지)를 관리하는 **스코프**를 생성하고 유지하며 다음 노드로 전달합니다.
*   **제어 흐름(Control Flow) 처리**: `돌려주기`(return), `멈추기`(break), `계속하기`(continue)처럼 프로그램의 일반적인 실행 순서를 변경하는 구문들을 위한 특별한 **신호(Signal)**를 감지하고 적절히 처리합니다.
*   **런타임 오류 대응**: 코드 실행 중에 발생하는 다양한 오류(예: 정의되지 않은 변수 사용, 잘못된 타입 연산)를 감지하여 보고하거나, 필요한 경우 프로그램 실행을 중단시킵니다.

## 실행기의 주요 구성 요소와 작동 방식

*   **`core/executer/index.ts`**:
    *   실행기의 출발점은 `executer<NodeType extends Executable>(node: NodeType, codeFile?: CodeFile): Promise<Scope>` 함수입니다.
        *   이 함수는 실행할 최상위 AST 노드(`node`, 보통 파일 전체를 나타내는 `Block` 노드)와, 선택적으로 현재 코드 파일의 정보(`codeFile`)를 인자로 받습니다.
        *   실행을 위한 새로운 `Scope` 객체를 생성하거나, 만약 `codeFile` 객체에 이전에 사용되었던 스코프(`ranScope`) 정보가 있다면 이를 재사용하여 여러 파일 실행 간의 상태를 유지하거나 모듈과 유사한 기능을 지원할 수 있습니다.
        *   주어진 `node`의 `execute(scope)` 메소드를 호출함으로써 AST의 실행 여정을 시작합니다.
        *   만약 실행 과정에서 `ReturnSignal`이나 `BreakSignal`과 같은 제어 흐름 신호가 함수나 반복문의 적절한 경계를 벗어나 최상위 레벨까지 도달한다면, 이는 문법적으로 유효하지 않은 사용으로 간주되어 `CannotReturnOutsideFunctionError`와 같은 특정 오류를 발생시킵니다.
        *   모든 실행이 정상적으로 완료되면, 최종 상태의 스코프 객체를 반환합니다. 이 스코프는 예를 들어 REPL(Read-Eval-Print Loop) 환경에서 다음 명령어 실행에 사용될 수 있습니다.
*   **`core/executer/scope.ts`**:
    *   `Scope` 클래스는 프로그램의 실행 상태, 특히 식별자(변수나 함수의 이름)와 그에 연결된 [값](./values.md) 또는 함수 객체를 저장하고 관리하는 메모리 공간과 같습니다.
    *   **계층적 스코프 (Lexical Scoping)**:
        *   스코프는 부모 스코프(parent)를 가질 수 있는 계층적 구조를 이룹니다. 이는 함수나 코드 블록 내부에 또 다른 함수나 코드 블록이 중첩될 때 유용합니다.
        *   어떤 식별자의 값을 찾을 때, 먼저 현재 스코프에서 찾아보고, 만약 없다면 부모 스코프, 또 그 부모 스코프로 거슬러 올라가며 찾습니다. 이러한 방식을 통해 달빛약속은 렉시컬 스코핑(lexical scoping) 또는 정적 스코핑(static scoping)이라 불리는 변수 유효 범위 규칙을 따릅니다.
        *   새로운 함수가 호출되거나 새로운 코드 블록(예: `만약` 문의 실행 부분)이 시작될 때, 현재 스코프를 부모로 하는 새로운 자식 스코프가 생성되어 독립적인 이름 공간을 제공하면서도 외부의 정보에 접근할 수 있게 합니다.
    *   **주요 기능 (메소드)**:
        *   `getVariable(name: string): ValueType`: 주어진 이름에 해당하는 변수의 값을 현재 스코프 또는 상위 스코프에서 찾아 반환합니다. 만약 해당 이름의 변수가 정의되어 있지 않다면 `NotDefinedIdentifierError` 오류를 발생시킵니다.
        *   `setVariable(name: string, value: ValueType)`: 현재 스코프 또는 가장 가까운 상위 스코프에서 해당 이름의 변수를 찾아 그 값을 갱신하거나, (언어의 규칙에 따라) 현재 스코프에 새로운 변수를 정의하고 값을 할당합니다.
        *   `defineVariable(name: string, value: ValueType)`: (만약 존재한다면) 오직 현재 스코프에만 새로운 변수를 정의합니다. 이미 같은 이름의 변수가 현재 스코프에 존재한다면 오류를 발생시킬 수 있습니다.
        *   `getFunctionObject(name: string): FunctionValue`: (또는 유사한 이름의 메소드) 주어진 이름에 해당하는 함수(약속) 객체를 스코프에서 찾아 반환합니다.
        *   `setFunctionObject(name: string, func: FunctionValue)`: 함수(약속) 객체를 스코프에 해당 이름으로 등록합니다.
        *   `createChildScope(): Scope`: 현재 스코프를 부모로 하는 새로운 자식 스코프를 생성하여 반환합니다.
*   **`core/executer/signals.ts`**:
    *   프로그램의 일반적인 순차적 실행 흐름을 변경하고자 할 때 사용되는 특별한 종류의 객체(신호)들을 정의합니다. 이들은 기술적으로는 `Error` 클래스를 상속하여 예외 처리 메커니즘을 통해 전파될 수 있지만, 실제 오류 상황을 의미하기보다는 특정 제어 흐름의 상태를 나타내는 데 사용됩니다.
    *   **`ReturnSignal`**: 함수(약속) 내에서 `돌려주기` 문이 실행될 때 발생합니다. 이 신호는 반환될 값과 함께 함수가 호출되었던 지점까지 거슬러 올라가며, 해당 함수의 실행을 정상적으로 중단시키고 최종 결과값을 전달하는 역할을 합니다. `executer` 함수는 이 신호가 함수 외부의 최상위 레벨에서 감지되면 오류로 처리합니다.
    *   **`BreakSignal`**: 반복문 내에서 `멈추기` (또는 이와 유사한 의미의 키워드) 문이 실행될 때 발생합니다. 이 신호는 현재 실행 중인 가장 안쪽 반복문의 실행을 즉시 중단시키고 반복문 다음 코드로 이동하도록 합니다. `executer` 함수는 이 신호가 반복문 외부의 최상위 레벨에서 감지되면 오류로 처리합니다.
    *   **`ContinueSignal`**: (만약 달빛약속에 해당 기능이 있다면) 반복문 내에서 `계속하기` (또는 이와 유사한 의미의 키워드) 문이 실행될 때 발생합니다. 이 신호는 현재 진행 중인 반복의 나머지 부분을 건너뛰고 즉시 다음 반복을 시작하도록 지시합니다.
    *   AST 노드의 `execute` 메소드 내에서 이러한 신호가 발생(throw)되면, 이는 호출 스택을 따라 상위로 전파되며, 함수 호출을 처리하는 노드나 반복문을 처리하는 노드와 같이 해당 신호를 적절히 처리할 수 있는 특정 노드에 의해 포착(catch)되어 프로그램의 흐름이 조절됩니다.

## 코드 실행의 여정

1.  **실행 시작**: `executer` 함수가 최상위 AST 노드(일반적으로 전체 소스 파일을 나타내는 `Block` 노드)와 함께 호출되며, 초기 스코프가 설정됩니다.
2.  **노드별 실행**:
    *   `executer`는 전달받은 노드의 `execute(scope)` 메소드를 호출합니다.
    *   각 AST 노드는 자신의 타입에 맞는 고유한 작업을 수행합니다.
        *   **`Block` 노드**: 포함하고 있는 자식 노드들의 `execute` 메소드를 순차적으로 호출합니다. 이때, 필요에 따라 새로운 자식 스코프를 생성하여 자식 노드들에게 전달함으로써, 블록 내부의 변수들이 외부와 격리되도록 할 수 있습니다.
        *   **`VariableDeclareNode`**: 변수의 이름과 초기값을 현재 스코프에 등록합니다. 만약 초기값이 또 다른 표현식이라면, 해당 표현식 노드의 `execute` 메소드를 먼저 호출하여 그 결과값을 얻은 후 등록합니다.
        *   **`AssignNode`**: 할당 연산자의 우변에 있는 표현식 노드의 `execute` 메소드를 호출하여 값을 얻고, 이 값을 좌변에 지정된 변수(스코프에서 해당 변수를 찾아)에 새롭게 할당(업데이트)합니다.
        *   **`IfStatement` 노드**: 조건식 노드의 `execute` 메소드를 호출하여 조건의 참/거짓을 평가하고, 그 결과에 따라 '참일 때 실행될 블록' 또는 '거짓일 때 실행될 블록'(또는 다음 `else if` 조건)의 `execute` 메소드를 호출합니다.
        *   **`FunctionDeclareNode`**: 함수(약속)의 이름, 파라미터 정보, 그리고 함수 몸체(실행될 코드 블록) 등을 담고 있는 `FunctionValue`라는 특별한 [값 객체](./values.md)를 생성하여, 현재 스코프에 해당 함수의 이름으로 등록합니다. 이때 함수 몸체가 바로 실행되지는 않습니다.
        *   **`FunctionCallNode`**:
            1.  스코프에서 호출하고자 하는 함수의 이름에 해당하는 `FunctionValue` 객체를 찾습니다.
            2.  함수에 전달할 각 인자(argument) 표현식 노드들의 `execute` 메소드를 호출하여 실제 인자 값들을 계산합니다.
            3.  함수 실행을 위한 새로운 자식 스코프를 생성하고, 이 스코프에 함수의 파라미터 이름들과 방금 계산한 인자 값들을 서로 연결하여 등록합니다.
            4.  찾아낸 `FunctionValue` 객체의 `run` (또는 이와 유사한) 메소드를 호출하거나, 함수 몸체에 해당하는 `Block` 노드의 `execute` 메소드를 이 새로운 실행 스코프와 함께 호출합니다.
            5.  만약 함수 실행 도중 `ReturnSignal`이 발생하면, 이 신호에 담겨있는 반환값을 포착하여 현재 `FunctionCallNode`의 최종 결과값으로 사용합니다.
        *   **`Loop` 노드**: 주어진 조건이 만족되는 동안 (또는 정해진 횟수만큼) 반복적으로 몸체에 해당하는 `Block` 노드의 `execute` 메소드를 호출합니다. 내부에서 `BreakSignal`이나 `ContinueSignal`이 발생하면 이를 감지하여 반복의 흐름을 적절히 제어합니다.
        *   **`ReturnNode`**: 반환하고자 하는 값을 나타내는 표현식 노드의 `execute` 메소드를 호출하여 값을 얻고, 이 값과 함께 `ReturnSignal`을 발생시켜 현재 함수의 실행을 중단하고 해당 값을 호출 지점으로 돌려보냅니다.
        *   그 외 숫자나 문자열 리터럴을 나타내는 노드, 또는 산술 연산을 나타내는 노드 등은 각각 자신을 평가하여 해당하는 [값 객체](./values.md)를 결과로 반환합니다.
3.  **신호의 전파와 처리**: 특정 AST 노드(주로 함수의 호출이나 반복문과 같은 제어 흐름을 다루는 노드)는 하위 노드들의 실행 과정에서 발생한 신호들을 적절히 포착하여 처리합니다. 예를 들어, `FunctionCallNode`는 자신이 호출한 함수 내부에서 발생한 `ReturnSignal`을 처리하여 함수의 반환 과정을 완료하고, `Loop` 노드는 내부에서 발생한 `BreakSignal`이나 `ContinueSignal`을 처리하여 반복의 흐름을 제어합니다.
4.  **실행 종료**: 최상위 노드의 실행이 모두 완료되면, `executer` 함수는 프로그램 실행 후의 최종 상태를 담고 있는 스코프를 반환합니다. 이 스코프는 예를 들어 대화형 실행 환경(REPL)에서 다음 명령어의 실행으로 이어지는 문맥으로 활용될 수 있습니다.

## 스코프와 값의 아름다운 협업

실행기는 스코프를 통해 프로그램의 상태(어떤 이름에 어떤 값이 연결되어 있는지)를 정교하게 관리하며, 각각의 AST 노드들은 이 스코프와 긴밀하게 상호작용하면서 [값](./values.md)을 읽거나 새로 기록합니다. 예를 들어, `Identifier` 노드가 실행될 때는 스코프에서 해당 식별자에 연결된 값을 조회하고, `AssignNode`가 실행될 때는 스코프의 특정 식별자에 새로운 값을 연결(할당)합니다. 이 모든 과정에서 생성되고, 전달되고, 조작되는 모든 데이터는 `core/value/` 디렉토리에 정의된 `ValueType`의 다양한 인스턴스들, 즉 달빛약속의 값들입니다.

## 다음 탐험은 어디로?

실행기가 AST 설계도를 따라 코드를 실행하면서 실제로 다루는 다양한 '값'들의 종류와 그 내부적인 표현 방식에 대해 더 궁금하시다면, 다음 탐험지인 [값 시스템 (Value System)](./values.md) 문서에서 그 흥미로운 세계를 자세히 들여다보실 수 있습니다.
