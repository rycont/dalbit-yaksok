# Machine Readable Error ì¶œë ¥

## ê°œìš”

ê¸°ë³¸ì ìœ¼ë¡œ ë‹¬ë¹› ì•½ì†ì˜ ì—ëŸ¬ ë©”ì‹œì§€ëŠ” ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í˜•ì‹(Human Readable)ìœ¼ë¡œ ì¶œë ¥ë©ë‹ˆë‹¤. í•˜ì§€ë§Œ IDE, ë¹Œë“œ ë„êµ¬, ë˜ëŠ” ìë™í™”ëœ ì‹œìŠ¤í…œì—ì„œ ì—ëŸ¬ë¥¼ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ” ê²½ìš°, **Machine Readable** í˜•ì‹(JSON)ìœ¼ë¡œ ì—ëŸ¬ë¥¼ ì¶œë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ì‚¬ìš© ë°©ë²•

`YaksokSession`ì„ ìƒì„±í•  ë•Œ `MACHINE_READABLE_ERROR` í”Œë˜ê·¸ë¥¼ í™œì„±í™”í•˜ë©´ ë©ë‹ˆë‹¤.

### ê¸°ë³¸ ì˜ˆì œ

```typescript
import { YaksokSession, FEATURE_FLAG } from '@dalbit-yaksok/core'

const session = new YaksokSession({
    flags: {
        [FEATURE_FLAG.MACHINE_READABLE_ERROR]: true,
    },
    stderr: (message: string) => {
        // messageëŠ” ì´ì œ JSON í˜•ì‹ì…ë‹ˆë‹¤
        console.error(message)
    }
})

session.addModule('main', 'ì •ì˜ë˜ì§€ì•Šì€ë³€ìˆ˜ ë³´ì—¬ì£¼ê¸°')
await session.runModule('main')
```

## ì¶œë ¥ í˜•ì‹

### Human Readable í˜•ì‹ (ê¸°ë³¸ê°’)

```
â”€â”€â”€â”€â”€

ğŸš¨  ë¬¸ì œê°€ ë°œìƒí–ˆì–´ìš” ğŸš¨
1ë²ˆì§¸ ì¤„ì˜ 1ë²ˆì§¸ ê¸€ì

> ë³€ìˆ˜ 'ì •ì˜ë˜ì§€ì•Šì€ë³€ìˆ˜'ê°€ ì •ì˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.

â”Œâ”€â”€â”€â”€â”€
â”‚  1  ì •ì˜ë˜ì§€ì•Šì€ë³€ìˆ˜ ë³´ì—¬ì£¼ê¸°
â”‚       ^
â””â”€â”€â”€â”€â”€
```

### Machine Readable í˜•ì‹ (JSON)

```json
{
  "type": "error",
  "message": "ë³€ìˆ˜ 'ì •ì˜ë˜ì§€ì•Šì€ë³€ìˆ˜'ê°€ ì •ì˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.",
  "position": {
    "line": 1,
    "column": 1
  },
  "fileName": "main",
  "context": {
    "startLine": 1,
    "endLine": 1,
    "lines": [
      {
        "lineNumber": 1,
        "content": "ì •ì˜ë˜ì§€ì•Šì€ë³€ìˆ˜ ë³´ì—¬ì£¼ê¸°",
        "isErrorLine": true
      }
    ]
  }
}
```

## MachineReadableError ì¸í„°í˜ì´ìŠ¤

```typescript
interface MachineReadableError {
    /**
     * ì—ëŸ¬ íƒ€ì… (í˜„ì¬ëŠ” 'error'ë§Œ ì§€ì›)
     */
    type: 'error'
    
    /**
     * ì—ëŸ¬ ë©”ì‹œì§€
     */
    message: string
    
    /**
     * ì—ëŸ¬ê°€ ë°œìƒí•œ ìœ„ì¹˜
     * @optional
     */
    position?: {
        line: number      // 1ë¶€í„° ì‹œì‘í•˜ëŠ” ì¤„ ë²ˆí˜¸
        column: number    // 1ë¶€í„° ì‹œì‘í•˜ëŠ” ì—´ ë²ˆí˜¸
    }
    
    /**
     * ì—ëŸ¬ê°€ ë°œìƒí•œ íŒŒì¼ ì´ë¦„
     * @optional
     */
    fileName?: string
    
    /**
     * ì—ëŸ¬ ì£¼ë³€ì˜ ì½”ë“œ ì»¨í…ìŠ¤íŠ¸
     * @optional
     */
    context?: {
        startLine: number
        endLine: number
        lines: Array<{
            lineNumber: number    // 1ë¶€í„° ì‹œì‘í•˜ëŠ” ì¤„ ë²ˆí˜¸
            content: string       // í•´ë‹¹ ì¤„ì˜ ì½”ë“œ
            isErrorLine: boolean  // ì—ëŸ¬ê°€ ë°œìƒí•œ ì¤„ì¸ì§€ ì—¬ë¶€
        }>
    }
    
    /**
     * ì¤‘ì²©ëœ ì—ëŸ¬ (ì›ì¸ ì—ëŸ¬)
     * @optional
     */
    child?: MachineReadableError
}
```

## ì‚¬ìš© ì‚¬ë¡€

### 1. IDE í”ŒëŸ¬ê·¸ì¸ ê°œë°œ

ì—ëŸ¬ ì •ë³´ë¥¼ êµ¬ì¡°í™”ëœ í˜•ì‹ìœ¼ë¡œ ë°›ì•„ IDEì— í‘œì‹œí•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```typescript
const session = new YaksokSession({
    flags: {
        [FEATURE_FLAG.MACHINE_READABLE_ERROR]: true,
    },
    stderr: (message: string) => {
        const error = JSON.parse(message)
        
        // IDEì— ì—ëŸ¬ í‘œì‹œ
        showDiagnostic({
            file: error.fileName,
            line: error.position?.line,
            column: error.position?.column,
            message: error.message,
        })
    }
})
```

### 2. CI/CD íŒŒì´í”„ë¼ì¸

ìë™í™”ëœ ë¹Œë“œ ì‹œìŠ¤í…œì—ì„œ ì—ëŸ¬ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```typescript
const session = new YaksokSession({
    flags: {
        [FEATURE_FLAG.MACHINE_READABLE_ERROR]: true,
    },
    stderr: (message: string) => {
        const error = JSON.parse(message)
        
        // ì—ëŸ¬ ë¡œê¹… ì‹œìŠ¤í…œì— ë³´ë‚´ê¸°
        logError({
            timestamp: new Date().toISOString(),
            file: error.fileName,
            position: error.position,
            message: error.message,
        })
    }
})
```

### 3. í¸ì§‘ê¸°/ì»´íŒŒì¼ëŸ¬ ê°œë°œ

ì–¸ì–´ ì„œë²„ë‚˜ ì»´íŒŒì¼ëŸ¬ì—ì„œ êµ¬ì¡°í™”ëœ ì—ëŸ¬ ì •ë³´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```typescript
const errors = []

const session = new YaksokSession({
    flags: {
        [FEATURE_FLAG.MACHINE_READABLE_ERROR]: true,
    },
    stderr: (message: string) => {
        errors.push(JSON.parse(message))
    }
})

// ëª¨ë“  ì—ëŸ¬ ì²˜ë¦¬
session.addModule('main', sourceCode)
await session.runModule('main')

// ì—ëŸ¬ ëª©ë¡ì„ ë‹¤ë¥¸ ë„êµ¬ë¡œ ì „ì†¡
sendErrorsToAnalyzer(errors)
```

## ì£¼ì˜ì‚¬í•­

- `MACHINE_READABLE_ERROR` í”Œë˜ê·¸ê°€ í™œì„±í™”ë˜ì§€ ì•Šìœ¼ë©´, ê¸°ë³¸ê°’ì¸ Human Readable í˜•ì‹ì´ ì‚¬ìš©ë©ë‹ˆë‹¤.
- Machine Readable í˜•ì‹ì˜ ì—ëŸ¬ ë©”ì‹œì§€ëŠ” í•­ìƒ ìœ íš¨í•œ JSONì…ë‹ˆë‹¤.
- ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ íŒŒì‹±í•  ë•ŒëŠ” `JSON.parse()`ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.

## ì˜ˆì œ ì½”ë“œ

### ì „ì²´ ì˜ˆì œ

```typescript
import { YaksokSession, FEATURE_FLAG, type MachineReadableError } from '@dalbit-yaksok/core'

async function runWithMachineReadableErrors() {
    const errors: MachineReadableError[] = []

    const session = new YaksokSession({
        flags: {
            [FEATURE_FLAG.MACHINE_READABLE_ERROR]: true,
        },
        stderr: (message: string) => {
            try {
                const error = JSON.parse(message) as MachineReadableError
                errors.push(error)
                console.log(`Error: ${error.message}`)
                if (error.position) {
                    console.log(`  at ${error.fileName}:${error.position.line}:${error.position.column}`)
                }
            } catch (e) {
                console.error('Failed to parse error:', e)
            }
        }
    })

    session.addModule('main', `
        ì •ì˜ë˜ì§€ì•Šì€ë³€ìˆ˜ ë³´ì—¬ì£¼ê¸°
    `)

    const result = await session.runModule('main')

    return {
        result,
        errors
    }
}

// ì‹¤í–‰
const { errors } = await runWithMachineReadableErrors()
console.log(`Total errors: ${errors.length}`)
```
