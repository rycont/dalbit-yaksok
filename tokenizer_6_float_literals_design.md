# 설계도: 1단계 (토크나이저) - 6. 실수 리터럴 토큰화 테스트 및 구현

**목표:** `Lexer`가 소수점(`.`)을 포함하는 숫자 시퀀스를 `FLOAT` 타입 토큰으로 인식하고, 해당 숫자 문자열을 리터럴 값으로 갖는 토큰을 생성하도록 합니다.

**이행 절차:**

1.  **`peekChar()` 헬퍼 메서드 작성 (필요시):**
    *   작업: `interpreter/lexer.go`에 `peekChar() rune` 메서드를 작성합니다. 이 메서드는 `l.readPosition` 위치의 문자를 반환하되, `Lexer`의 현재 위치(`position`, `readPosition`, `ch`)는 변경하지 않습니다. EOF를 넘어서면 0을 반환합니다.
    *   확인: `peekChar`가 다음 문자를 정확히 반환하고 위치를 변경하지 않는지 확인합니다.
2.  **`readNumber()` 헬퍼 메서드 작성 또는 수정:**
    *   작업: `interpreter/lexer.go`의 기존 `readInteger()`를 `readNumber()`로 확장하거나 새로 작성합니다.
        *   먼저 `isDigit(l.ch)`를 사용하여 정수 부분을 읽습니다.
        *   만약 `l.ch == '.'` 이고 `isDigit(l.peekChar())` (다음 문자가 숫자)이면, 소수점과 그 이후의 숫자들을 계속 읽어 하나의 숫자 문자열로 합칩니다. 이 과정에서 `l.readChar()`를 호출하여 실제 위치를 이동시킵니다.
        *   최종적으로 구성된 전체 숫자 문자열(정수부+소수점+소수부 또는 정수부만)과, 이것이 실수인지 여부를 나타내는 `bool` 값을 반환합니다.
        *   `l.ch`는 `readNumber` 호출 후 숫자 시퀀스(정수 또는 실수) 바로 다음 문자를 가리키도록 합니다.
    *   확인: `readNumber`가 "123", "3.14" 같은 입력을 올바르게 처리하고, 각각 ( "123", false ), ( "3.14", true )를 반환하는지 확인합니다. "123."이나 ".45" 같은 형태는 초기에는 지원하지 않고, "숫자.숫자" 형태만 실수로 간주합니다. (즉, `.` 뒤에 숫자가 와야 함).
3.  **`NextToken()` 메서드에 실수 처리 로직 추가/수정:**
    *   작업: `interpreter/lexer.go`의 `NextToken()` 함수에서 숫자 처리 부분을 수정합니다.
        *   `isDigit(l.ch)`인 경우 `readNumber()`를 호출합니다. (소수점으로 시작하는 숫자는 `default`에서 별도 처리하거나, `isDigit` 조건 확장 필요. 여기서는 숫자로 시작하는 경우만 먼저 처리)
        *   `readNumber()`로부터 숫자 문자열과 실수 여부(`isFloat`)를 받습니다.
        *   `isFloat`이 `true`이면 `FLOAT` 토큰을, `false`이면 `INT` 토큰을 생성합니다.
        *   이 로직은 `readInteger`를 호출하던 부분을 대체합니다. `FLOAT` 토큰 타입을 `token.go`에 추가해야 합니다.
        *   토큰 생성 후 `return tok`을 하여 `NextToken` 끝의 `l.readChar()`가 호출되지 않도록 합니다.
    *   확인: `NextToken`이 정수와 실수를 구분하여 올바른 타입의 토큰을 생성하는지 확인합니다.
4.  **실수 리터럴 토큰화 테스트 케이스 작성 및 실행:**
    *   작업: `interpreter/lexer_test.go`에 `TestNextToken_FloatsAndMixedNumbers` 테스트 함수를 작성합니다.
        *   입력: `"3.14"` -> 예상: `FLOAT("3.14")`, `EOF("")`
        *   입력: `"0.5"` -> 예상: `FLOAT("0.5")`, `EOF("")`
        *   입력: `"123.456"` -> 예상: `FLOAT("123.456")`, `EOF("")`
        *   입력: `"10.0 + 0.5"` -> 예상: `FLOAT("10.0")`, `PLUS("+")`, `FLOAT("0.5")`, `EOF("")`
        *   입력: `"123"` -> 예상: `INT("123")`, `EOF("")` (정수도 여전히 잘 되어야 함)
        *   입력: `"1. + 2"` -> 예상: `INT("1")`, `ILLEGAL(".")` (또는 `DOT` 토큰), `PLUS("+")`, `INT("2")`, `EOF("")` (`.` 뒤에 숫자가 없는 경우)
        *   입력: `".5"` -> 예상: `ILLEGAL(".")` (또는 `DOT` 토큰), `INT("5")`, `EOF("")` (숫자 없이 `.`으로 시작하는 경우)
    *   확인: 다양한 실수 및 정수 입력에 대해 올바른 토큰 시퀀스가 생성되는지 확인합니다.
5.  **모든 관련 테스트 실행 (성공 확인):**
    *   작업: `go test -v yak/interpreter` 명령으로 모든 `Lexer` 테스트를 실행합니다.
    *   확인: 새로 추가된 실수 처리 테스트 및 기존의 모든 테스트가 성공적으로 통과하는지 확인합니다.
