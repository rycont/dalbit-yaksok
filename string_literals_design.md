# 설계도: 3. 문자열 리터럴 파싱 및 평가

**목표:** 입력 문자열이 따옴표(`"`)로 둘러싸인 문자열 리터럴일 경우, 이를 일반 문자열 값으로 변환하여 반환하도록 `Evaluate` 함수를 확장합니다.

**이행 절차:**

1.  **문자열 리터럴 파싱 테스트 케이스 작성:**
    *   작업: `interpreter/interpreter_test.go`에 `TestEvaluateStringLiterals`라는 테스트 함수를 추가합니다. 이 함수는 다음 케이스들을 포함해야 합니다:
        *   `"\"안녕하세요\""` 입력 시 `"안녕하세요"` (문자열)와 `nil` 에러 반환
        *   `"\"\""` (빈 문자열) 입력 시 `""` (문자열)와 `nil` 에러 반환
        *   `"\"여기는 공백이 있는 문자열입니다\""` 입력 시 `"여기는 공백이 있는 문자열입니다"`와 `nil` 에러 반환
        *   `"\"숫자 123과 함께\""` 입력 시 `"숫자 123과 함께"`와 `nil` 에러 반환
        *   (선택 사항) `"\"이스케이프 \\\" 문자\""` 와 같은 이스케이프 시퀀스를 포함하는 문자열 테스트 (초기에는 지원하지 않아도 됨)
    *   확인: 테스트 케이스가 문자열 리터럴의 시작과 끝 따옴표를 정확히 제거하고 내부 내용만 반환하는지 확인합니다.
2.  **문자열 리터럴 테스트 실행 (실패 확인):**
    *   작업: `go test -v yak/interpreter` 명령으로 테스트를 실행합니다.
    *   확인: `TestEvaluateStringLiterals`의 모든 케이스가 실패하는지 확인합니다 (현재 `Evaluate`는 숫자만 처리하거나, 숫자가 아니면 에러를 반환함). 실패 메시지는 "cannot evaluate expression as a number: ..." 또는 유사한 내용이어야 합니다.
3.  **문자열 리터럴 파싱 로직 구현:**
    *   작업: `interpreter/interpreter.go`의 `Evaluate` 함수를 수정합니다.
        1.  먼저 입력 `expression`이 길이가 2 이상이고, 첫 번째 문자와 마지막 문자가 모두 큰따옴표(`"`)인지 확인합니다.
        2.  위 조건이 참이면, 첫 번째와 마지막 따옴표를 제외한 부분 문자열을 추출하여 반환 값으로 하고, 에러는 `nil`로 합니다.
        3.  문자열 리터럴이 아니면, 기존의 숫자 파싱 로직(실수 먼저, 그 다음 정수)을 시도합니다.
        4.  어떤 패턴에도 해당하지 않으면 기존의 에러 메시지를 반환합니다.
    *   확인: 문자열 리터럴을 식별하는 조건이 정확한지, 따옴표 제거가 올바르게 수행되는지 확인합니다. 숫자 파싱 로직과의 순서 및 통합이 자연스러운지 확인합니다.
4.  **모든 리터럴 테스트 실행 (성공 확인):**
    *   작업: `go test -v yak/interpreter` 명령으로 테스트를 다시 실행합니다.
    *   확인: `TestEvaluateIntegerLiterals`, `TestEvaluateFloatLiterals`, 그리고 새로 추가된 `TestEvaluateStringLiterals`의 모든 케이스가 성공하는지 확인합니다.
