# 설계도: 1단계 (토크나이저) - 5. 정수 리터럴 토큰화 테스트 및 구현

**목표:** `Lexer`가 연속된 숫자 시퀀스를 단일 `INT` 타입 토큰으로 인식하고, 해당 숫자 문자열을 리터럴 값으로 갖는 토큰을 생성하도록 합니다.

**이행 절차:**

1.  **`isDigit()` 헬퍼 함수 및 `readInteger()` 헬퍼 메서드 작성:**
    *   작업: `interpreter/lexer.go`에 다음을 작성합니다:
        *   `isDigit(ch rune) bool`: 입력된 룬이 '0'에서 '9' 사이의 숫자인지 판별합니다.
        *   `readInteger() string`: 현재 `l.ch`가 숫자인 동안 `l.readChar()`를 호출하여 연속된 숫자 문자열을 구성하고 반환합니다. 이 메서드는 숫자 시퀀스를 모두 읽고, `l.ch`는 숫자 시퀀스 바로 다음 문자를 가리키게 됩니다.
    *   확인: `isDigit`가 정확히 동작하는지, `readInteger`가 숫자 문자열을 올바르게 만들고 `Lexer`의 내부 상태(`ch`, `position`, `readPosition`)를 정확히 업데이트하는지 확인합니다.
2.  **`NextToken()` 메서드에 정수 처리 로직 추가:**
    *   작업: `interpreter/lexer.go`의 `NextToken()` 함수 내 `switch l.ch`의 `default` 케이스 부분을 수정합니다.
        *   `default` 케이스의 시작 부분에서 `isDigit(l.ch)`를 확인합니다.
        *   만약 `l.ch`가 숫자이면, `l.readInteger()`를 호출하여 숫자 리터럴을 얻고, `INT` 타입의 토큰을 생성하여 반환합니다. 이 경우, `readInteger`가 이미 `l.ch`를 다음 토큰의 시작 문자로 옮겼으므로, `NextToken`의 마지막에 있는 `l.readChar()`를 호출하면 안 됩니다. 따라서 `readInteger`를 호출하여 토큰을 만든 후에는 바로 `return tok`을 해야 합니다.
        *   숫자가 아니면 기존의 `ILLEGAL` 토큰 생성 로직을 유지합니다. (나중에 식별자 등으로 확장)
    *   확인: `NextToken`이 숫자 시퀀스를 만나면 `INT` 토큰을 올바르게 생성하고, 그렇지 않으면 다른 로직으로 넘어가는지 확인합니다. `readChar` 호출 흐름에 주의합니다.
3.  **정수 리터럴 토큰화 테스트 케이스 작성 및 실행:**
    *   작업: `interpreter/lexer_test.go`에 `TestNextToken_Integers` 테스트 함수를 작성합니다. 다음 케이스들을 포함합니다:
        *   입력: `"123"` -> 예상: `INT("123")`, `EOF("")`
        *   입력: `"0"` -> 예상: `INT("0")`, `EOF("")`
        *   입력: `"123 456"` -> 예상: `INT("123")`, `INT("456")`, `EOF("")` (공백 처리기가 이미 있어야 함)
        *   입력: `"10+20"` -> 예상: `INT("10")`, `PLUS("+")`, `INT("20")`, `EOF("")`
    *   확인: 테스트가 다양한 정수 입력에 대해 올바른 `INT` 토큰과 리터럴 값을 생성하는지, 그리고 다른 토큰과 혼합된 경우에도 잘 동작하는지 확인합니다.
4.  **모든 관련 테스트 실행 (성공 확인):**
    *   작업: `go test -v yak/interpreter` 명령으로 모든 `Lexer` 테스트를 실행합니다.
    *   확인: 새로 추가된 정수 처리 테스트 및 기존의 모든 테스트가 성공적으로 통과하는지 확인합니다.
